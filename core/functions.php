<?php
/**
 * @package		CleverStyle CMS
 * @author		Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright	Copyright (c) 2011-2013, Nazar Mokrynskyi
 * @license		MIT License, see license.txt
 */
/**
 * Base system functions, do not edit this file, or make it very carefully
 * otherwise system workability may be broken
 */

/**
 * Auto Loading of classes
 */
spl_autoload_register(function ($class) {
	if (substr($class, 0, 3) == 'cs\\') {
		$class	= substr($class, 3);
	}
	$class	= explode('\\', $class);
	$class	= [
		'namespace'	=> count($class) > 1 ? implode('/', array_slice($class, 0, -1)) : '',
		'name'		=> array_pop($class)
	];
	_require_once(CLASSES.'/'.$class['namespace'].'/'.$class['name'].'.php', false) ||
	_require_once(ENGINES.'/'.$class['namespace'].'/'.$class['name'].'.php', false) ||
	(
		$class['namespace'] == "modules/$class[name]" && _require_once(MODULES.'/'.$class['name'].'/'.$class['name'].'.php', false)
	) ||
	(
		$class['namespace'] == "plugins/$class[name]" && _require_once(PLUGINS.'/'.$class['name'].'/'.$class['name'].'.php', false)
	);
});
/**
 * Correct termination from any place of engine
 */
function __finish () {
	global $Core;
	if (is_object($Core)) {
		$Core->__finish();
	}
	exit;
}
/**
 * Enable of errors processing
 */
function errors_on () {
	global $Error;
	is_object($Error) && $Error->error = true;
}
/**
 * Disabling of errors processing
 */
function errors_off () {
	global $Error;
	is_object($Error) && $Error->error = false;
}
/**
 * Enabling of page interface
 */
function interface_on () {
	global $Page;
	if (is_object($Page)) {
		$Page->interface = true;
	} else {
		global $interface;
		$interface = true;
	}
}
/**
 * Disabling of page interface
 */
function interface_off () {
	global $Page;
	if (is_object($Page)) {
		$Page->interface = false;
	} else {
		global $interface;
		$interface = false;
	}
}
/**
 * Get file url by it's destination in file system
 *
 * @param string		$source
 *
 * @return bool|string
 */
function url_by_source ($source) {
	$source = realpath($source);
	if (mb_strpos($source, DIR.'/') === 0) {
		global $Config;
		if (is_object($Config)) {
			return str_replace(DIR, $Config->base_url(), $source);
		}
	}
	return false;
}
/**
 * Get file destination in file system by it's url
 *
 * @param string		$url
 *
 * @return bool|string
 */
function source_by_url ($url) {
	global $Config;
	if (mb_strpos($url, $Config->base_url()) === 0) {
		if (is_object($Config)) {
			return str_replace($Config->base_url(), DIR, $url);
		}
	}
	return false;
}
/**
 * Public cache cleaning
 *
 * @return bool
 */
function clean_pcache () {
	$ok = true;
	$list = get_files_list(PCACHE, false, 'fd', true, true, 'name|desc');
	foreach ($list as $item) {
		if (is_writable($item)) {
			is_dir($item) ? @rmdir($item) : @unlink($item);
		} else {
			$ok = false;
		}
	}
	unset($list, $item);
	return $ok;
}
/**
 * Formatting of time in seconds to human-readable form
 *
 * @param int		$time	Time in seconds
 *
 * @return string
 */
function format_time ($time) {
	global $L;
	$res = [];
	if ($time >= 31536000) {
		$time_x = round($time/31536000);
		$time -= $time_x*31536000;
		$res[] = $L->time($time_x, 'y');
	}
	if ($time >= 2592000) {
		$time_x = round($time/2592000);
		$time -= $time_x*2592000;
		$res[] = $L->time($time_x, 'M');
	}
	if($time >= 86400) {
		$time_x = round($time/86400);
		$time -= $time_x*86400;
		$res[] = $L->time($time_x, 'd');
	}
	if($time >= 3600) {
		$time_x = round($time/3600);
		$time -= $time_x*3600;
		$res[] = $L->time($time_x, 'h');
	}
	if ($time >= 60) {
		$time_x = round($time/60);
		$time -= $time_x*60;
		$res[] = $L->time($time_x, 'm');
	}
	if ($time > 0 || empty($res)) {
		$res[] = $L->time($time, 's');
	}
	return implode(' ', $res);
}
/**
 * Formatting of data size in bytes to human-readable form
 *
 * @param int		$size
 * @param bool|int	$round
 *
 * @return float|string
 */
function format_filesize ($size, $round = false) {
	global $L;
	$unit = '';
	if($size >= 1099511627776) {
		$size = $size/1099511627776;
		$unit = ' '.$L->TB;
	} elseif($size >= 1073741824) {
		$size = $size/1073741824;
		$unit = ' '.$L->GB;
	} elseif ($size >= 1048576) {
		$size = $size/1048576;
		$unit = ' '.$L->MB;
	} elseif ($size >= 1024) {
		$size = $size/1024;
		$unit = ' '.$L->KB;
	} else {
		$size = $size." ".$L->Bytes;
	}
	return $round ? round($size, $round).$unit : $size;
}
/**
 * Function for setting cookies on all mirrors and taking into account cookies prefix. Parameters like in system function, but $path, $domain and $secure
 * are skipped, they are detected automatically, and $api parameter added in the end.
 *
 * @param string     $name
 * @param string     $value
 * @param int        $expire
 * @param bool       $httponly
 * @param bool       $api		Is this cookie setting during api request (in most cases it is not necessary to change this parameter)
 *
 * @return bool
 */
function _setcookie ($name, $value, $expire = 0, $httponly = false, $api = false) {
	static $path, $domain, $prefix, $secure;
	global $Config, $Core;
	if (!isset($prefix) && is_object($Config)) {
		$prefix		= $Config->core['cookie_prefix'];
		$secure		= $Config->server['protocol'] == 'https';
		if (
			$Config->server['mirror_index'] == -1 ||
			!isset(
				$Config->core['mirrors_cookie_domain'][$Config->server['mirror_index']],
				$Config->core['mirrors_cookie_path'][$Config->server['mirror_index']]
			)
		) {
			$domain	= $Config->core['cookie_domain'];
			$path	= $Config->core['cookie_path'];
		} else {
			$domain	= $Config->core['mirrors_cookie_domain'][$Config->server['mirror_index']];
			$path	= $Config->core['mirrors_cookie_path'][$Config->server['mirror_index']];
		}
	}
	if (!isset($prefix)) {
		$prefix	= '';
	}
	$_COOKIE[$prefix.$name] = $value;
	if (!$api && is_object($Core) && is_object($Config) && isset($Config->core['cookie_sync']) && $Config->core['cookie_sync']) {
		$data = [
			'name'		=> $name,
			'value'		=> $value,
			'expire'	=> $expire,
			'httponly'	=> $httponly
		];
		$Core->register_trigger(
			'System/Index/preload',
			function () use ($prefix, $data, $domain) {
				global $Config, $Key, $User, $db;
				if (count($Config->core['mirrors_cookie_domain'])) {
					$mirrors_url			= $Config->core['mirrors_url'];
					$mirrors_cookie_domain	= $Config->core['mirrors_cookie_domain'];
					$database				= $db->{$Config->module('System')->db('keys')}();
					$data['check']			= md5($User->ip.$User->forwarded_for.$User->client_ip.$User->user_agent._json_encode($data));
					$urls					= [];
					if ($Config->server['mirror_index'] != -1 && $domain != $Config->core['cookie_domain']) {
						$url	= $Config->core_url();
						if ($Key->add($database, $key = $Key->generate($database), $data)) {
							$urls[] = $url.'/api/System/user/setcookie/'.$key;
						}
						unset($url);
					}
					foreach ($mirrors_cookie_domain as $i => $d) {
						$mirrors_url[$i] = explode(';', $mirrors_url[$i], 2)[0];
						if ($d && $d != $domain) {
							if ($Key->add($database, $key = $Key->generate($database), $data)) {
								$urls[]	= $mirrors_url[$i].'/api/System/user/setcookie/'.$key;
							}
						}
					}
					if (!empty($urls)) {
						$setcookie	= isset($_COOKIE[$prefix.'setcookie']) ? (_json_decode($_COOKIE[$prefix.'setcookie']) ?: []) : [];
						$setcookie	= array_merge($setcookie, $urls);
						setcookie($prefix.'setcookie', $_COOKIE[$prefix.'setcookie'] = _json_encode($setcookie));
					}
				}
			}
		);
	}
	if (isset($domain)) {
		return setcookie(
			$prefix.$name,
			$value,
			$expire,
			$path,
			$domain,
			$secure,
			$httponly
		);
	} else {
		return setcookie(
			$prefix.$name,
			$value,
			$expire,
			'/',
			$_SERVER['HTTP_HOST'],
			false,
			$httponly
		);
	}
}
/**
 * Function for getting of cookies, taking into account cookies prefix
 *
 * @param $name
 *
 * @return bool
 */
function _getcookie ($name) {
	static $prefix;
	if (!isset($prefix)) {
		global $Config;
		$prefix = is_object($Config) && $Config->core['cookie_prefix'] ? $Config->core['cookie_prefix'].'_' : '';
	}
	return isset($_COOKIE[$prefix.$name]) ? $_COOKIE[$prefix.$name] : false;
}
/**
 * Get list of timezones
 *
 * @return array
 */
function get_timezones_list () {
	global $Cache;
	if (!is_object($Cache) || ($timezones = $Cache->timezones) === false) {
		$tzs = timezone_identifiers_list();
		$timezones_ = $timezones = [];
		foreach ($tzs as $tz) {
			$offset		= (new DateTimeZone($tz))->getOffset(new DateTime);
			$offset_	=	($offset < 0 ? '-' : '+').
							str_pad(floor(abs($offset / 3600)), 2, 0, STR_PAD_LEFT).':'.
							str_pad(abs(($offset % 3600) / 60), 2, 0, STR_PAD_LEFT);
			$timezones_[(39600 + $offset).$tz] = [
				'key'	=> strtr($tz, '_', ' ').' ('.$offset_.')',
				'value'	=> $tz
			];
		}
		unset($tzs, $tz, $offset);
		ksort($timezones_, SORT_NATURAL);
		/**
		 * @var array $offset
		 */
		foreach ($timezones_ as $tz) {
			$timezones[$tz['key']] = $tz['value'];
		}
		unset($timezones_, $tz);
		if (is_object($Cache)) {
			$Cache->timezones = $timezones;
		}
	}
	return $timezones;
}
/**
 * Check version of core DB
 *
 * @return bool	If version unsatisfactory - returns <b>false</b>
 */
function check_db () {
	global $Core, $db;
	global ${$Core->db_type};
	if (!${$Core->db_type}) {
		return true;
	}
	preg_match('/[\.0-9]+/', $db->server(), $db_version);
	return (bool)version_compare($db_version[0], ${$Core->db_type}, '>=');
}
/**
 * Check PHP version
 *
 * @return bool	If version unsatisfactory - returns <b>false</b>
 */
function check_php () {
	global $PHP;
	return (bool)version_compare(PHP_VERSION, $PHP, '>=');
}
/**
 * Check existence and version of mcrypt
 *
 * @param int		$mode	<b>0</b> - existence of library (if exists, current version will be returned)<br>
 * 							<b>1</b> - is version satisfactory
 *
 * @return array
 */
function check_mcrypt ($mode = 0) {
	static $mcrypt_data;
	if (!isset($mcrypt_data)) {
		ob_start();
		@phpinfo(INFO_MODULES);
		$mcrypt_version = ob_get_clean();
		preg_match(
			'#mcrypt support.*?(enabled|disabled)(.|\n)*?Version.?</td><td class="v">(.*?)[\n]?</td></tr>#',
			$mcrypt_version,
			$mcrypt_version
		);
		$mcrypt_data[0] = $mcrypt_version[1] == 'enabled' ? trim($mcrypt_version[3]) : false;
		global $mcrypt;
		$mcrypt_data[1] = $mcrypt_data[0] ? (bool)version_compare($mcrypt_data[0], $mcrypt, '>=') : false;
	}
	return $mcrypt_data[$mode];
}
/**
 * Check existence of zlib library
 *
 * @return bool
 */
function zlib () {
	return extension_loaded('zlib');
}
/**
 * Check autocompression state of zlib library
 *
 * @return bool
 */
function zlib_compression () {
	return zlib() && strtolower(ini_get('zlib.output_compression')) != 'off';
}
/**
 * Returns autocompression level of zlib library
 *
 * @return bool
 */
function zlib_compression_level () {
	return ini_get('zlib.output_compression_level');
}
/**
 * Check existence of curl library
 *
 * @return bool
 */
function curl () {
	return extension_loaded('curl');
}
/**
 * Check existence of apc module
 *
 * @return bool
 */
function apc () {
	return extension_loaded('apc');
}
/**
 * Check existence of memcache module
 *
 * @return bool
 */
function memcached () {
	return extension_loaded('memcached');
}
/**
 * Check of "display_errors" configuration of php.ini
 *
 * @return bool
 */
function display_errors () {
	return (bool)ini_get('display_errors');
}
/**
 * Returns server type
 *
 * @return string
 */
function server_api () {
	global $L;
	ob_start();
	phpinfo(INFO_GENERAL);
	$tmp = ob_get_clean();
	preg_match('/Server API <\/td><td class="v">(.*?) <\/td><\/tr>/', $tmp, $tmp);
	if ($tmp[1]) {
		return $tmp[1];
	} else {
		return $L->indefinite;
	}
}
/**
 * Get multilingual value from $Config->core array
 *
 * @param string $item
 *
 * @return bool|string
 */
function get_core_ml_text ($item) {
	global $Config, $Text;
	if (!(is_object($Config) && is_object($Text))) {
		return false;
	}
	return $Text->process($Config->module('System')->db('texts'), $Config->core[$item], true, true);
}
/**
 * Pages navigation based on links
 *
 * @param int					$page		Current page
 * @param int					$total		Total pages number
 * @param bool|Closure|string	$url		Adds <i>formaction</i> parameter to every button<br>
 * 											if <b>false</b> - only form parameter <i>page</i> will we added<br>
 * 											if string - it will be formatted with sprintf with one parameter - page number<br>
 * 											if Closure - one parameter will be given, Closure should return url string
 * @param bool					$head_links	If <b>true</b> - links with rel="prev" and rel="next" will be added
 *
 * @return bool|string						<b>false</b> if single page, otherwise string, set of navigation links
 */
function pages ($page, $total, $url = false, $head_links = false) {
	if ($total == 1) {
		return false;
	}
	global $Page;
	$output	= [];
	if ($total <= 11) {
		for ($i = 1; $i <= $total; ++$i) {
			$output[]	= [
				$i,
				[
					'href'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
					'class'	=> $i == $page ? 'cs-button ui-selected' : 'cs-button'
				]
			];
			if ($head_links && $url !== false && ($i == $page - 1 || $i == $page + 1)) {
				$Page->link([
					'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
					'rel'	=> $i == $page - 1 ? 'prev' : ($i == $page + 1 ? 'next' : false)
				]);
			}
		}
	} else {
		if ($page <= 5) {
			for ($i = 1; $i <= 7; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
						'class'	=> $i == $page ? 'cs-button ui-selected' : 'cs-button'
					]
				];
				if ($head_links && $url !== false && ($i == $page - 1 || $i == $page + 1)) {
					$Page->link([
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'rel'	=> $i == $page - 1 ? 'prev' : ($i == $page + 1 ? 'next' : false)
					]);
				}
			}
			$output[]	= [
				'...',
				[
					'class'	=> 'cs-button ui-state-disabled'
				]
			];
			for ($i = $total - 2; $i <= $total; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'class'	=> 'cs-button'
					]
				];
			}
		} elseif ($page >= $total - 4) {
			for ($i = 1; $i <= 3; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'class'	=> 'cs-button'
					]
				];
			}
			$output[]	= [
				'...',
				[
					'class'	=> 'cs-button ui-state-disabled'
				]
			];
			for ($i = $total - 6; $i <= $total; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
						'class'	=> $i == $page ? 'cs-button ui-selected' : 'cs-button'
					]
				];
				if ($head_links && $url !== false && ($i == $page - 1 || $i == $page + 1)) {
					$Page->link([
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'rel'	=> $i == $page - 1 ? 'prev' : ($i == $page + 1 ? 'next' : false)
					]);
				}
			}
		} else {
			for ($i = 1; $i <= 2; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'class'	=> 'cs-button'
					]
				];
			}
			$output[]	= [
				'...',
				[
					'class'	=> 'cs-button ui-state-disabled'
				]
			];
			for ($i = $page - 1; $i <= $page + 3; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
						'class'	=> $i == $page ? 'cs-button ui-selected' : 'cs-button'
					]
				];
				if ($head_links && $url !== false && ($i == $page - 1 || $i == $page + 1)) {
					$Page->link([
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'rel'	=> $i == $page - 1 ? 'prev' : ($i == $page + 1 ? 'next' : false)
					]);
				}
			}
			$output[]	= [
				'...',
				[
					'class'	=> 'cs-button ui-state-disabled'
				]
			];
			for ($i = $total - 1; $i <= $total; ++$i) {
				$output[]	= [
					$i,
					[
						'href'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'class'	=> 'cs-button'
					]
				];
			}
		}
	}
	return h::{'a'}($output);
}
/**
 * Pages navigation based on buttons (for search forms, etc.)
 *
 * @param int					$page		Current page
 * @param int					$total		Total pages number
 * @param bool|Closure|string	$url		Adds <i>formaction</i> parameter to every button<br>
 * 											if <b>false</b> - only form parameter <i>page</i> will we added<br>
 * 											if string - it will be formatted with sprintf with one parameter - page number<br>
 * 											if Closure - one parameter will be given, Closure should return url string
 *
 * @return bool|string						<b>false</b> if single page, otherwise string, set of navigation buttons
 */
function pages_buttons ($page, $total, $url = false) {
	if ($total == 1) {
		return false;
	}
	$output	= [];
	if ($total <= 11) {
		for ($i = 1; $i <= $total; ++$i) {
			$output[]	= [
				$i,
				[
					'formaction'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
					'value'			=> $i,
					'type'			=> $i == $page ? 'button' : 'submit',
					'class'			=> $i == $page ? 'ui-selected' : false
				]
			];
		}
	} else {
		if ($page <= 5) {
			for ($i = 1; $i <= 7; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
						'value'			=> $i == $page ? false : $i,
						'type'			=> $i == $page ? 'button' : 'submit',
						'class'			=> $i == $page ? 'ui-selected' : false
					]
				];
			}
			$output[]	= [
				'...',
				[
					'type'			=> 'button',
					'disabled'
				]
			];
			for ($i = $total - 2; $i <= $total; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'value'			=> $i,
						'type'			=> 'submit'
					]
				];
			}
		} elseif ($page >= $total - 4) {
			for ($i = 1; $i <= 3; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'value'			=> $i,
						'type'			=> 'submit'
					]
				];
			}
			$output[]	= [
				'...',
				[
					'type'			=> 'button',
					'disabled'
				]
			];
			for ($i = $total - 6; $i <= $total; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
						'value'			=> $i == $page ? false : $i,
						'type'			=> $i == $page ? 'button' : 'submit',
						'class'			=> $i == $page ? 'ui-selected' : false
					]
				];
			}
		} else {
			for ($i = 1; $i <= 2; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'value'			=> $i,
						'type'			=> 'submit'
					]
				];
			}
			$output[]	= [
				'...',
				[
					'type'			=> 'button',
					'disabled'
				]
			];
			for ($i = $page - 1; $i <= $page + 3; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $i == $page || $url === false ? false : ($url instanceof Closure ? $url($i) : sprintf($url, $i)),
						'value'			=> $i == $page ? false : $i,
						'type'			=> $i == $page ? 'button' : 'submit',
						'class'			=> $i == $page ? 'ui-selected' : false
					]
				];
			}
			$output[]	= [
				'...',
				[
					'type'			=> 'button',
					'disabled'
				]
			];
			for ($i = $total - 1; $i <= $total; ++$i) {
				$output[]	= [
					$i,
					[
						'formaction'	=> $url instanceof Closure ? $url($i) : sprintf($url, $i),
						'value'			=> $i,
						'type'			=> 'submit'
					]
				];
			}
		}
	}
	return h::{'button[name=page]'}($output);
}